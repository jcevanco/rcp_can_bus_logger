#!/bin/sh
#set -x  ## Uncomment to get a trace
# (tabs are 3-spaces in width)

# 2020-Sep-12
# This material is free and withhout warranty.  Use it in any way you see fit.

# This script is designed to process one or more files that contain CAN messages
# logged by a lua/logger script runing on a RaceCapture device.

# ------------------------------------------------------------------------------
# set regular expressions (REs) for valid CAN-message and time-sync line formats
# ------------------------------------------------------------------------------
DATE='[0-9]{4}(-[0-9]{1,2}){2}'
TIME='([0-9]{1,2}:){2}[0-9]{1,2}\.[0-9]{1,3}'
UP_TIME='[0-9]{1,9}'

RAW_HEX='[12] [0-9]{1,9} 0x[0-9A-Fa-f]{1,8} [0-9]{1,2}( 0x[0-9A-Fa-f]{1,2}){1,8}'
RAW_DEC='[12] [0-9]{1,9} 0x[0-9A-Fa-f]{1,8} [0-9]{1,2}( [0-9]{1,3}){1,8}'

# 
DATE_TIME=$DATE' '$TIME

# valid time-sync record with ONLY full date/time-stamp plus upTime
TIME_SYNC=$DATE_TIME' '$UP_TIME

# valid hexadecimal-format CAN message without date/time-stamp (short format)
RAW_HEX_SHORT=$UP_TIME' '$RAW_HEX

# valid hexadecimal-format CAN message with full date/time-stamp (long format)
RAW_HEX_LONG=$DATE_TIME' '$RAW_HEX_SHORT

# valid decimal-format CAN message without date/time-stamp (short format)
RAW_DEC_SHORT=$UPT_TIME' '$RAW_DEC

# valid decimal-format CAN message with full date/time-stamp (long format)
RAW_DEC_LONG=$DATE_TIME' '$RAW_DEC_SHORT

# ------------------------------------------------------------------------------

GENERATE_CAN_ID_FILE='1'
GENERATE_PIDs_FILE='1'
DO_SORTING='1'
OUTPUT_MBZ_FORMAT='0'

# quick 'n dirty options parsing
while true
do
	if test "$1" = '-h'
	then
		echo '
Synopsis: processCANmsgLogs.sh [-h][-c][-p][-n][-m] <log file pathname> ...
   where: -h : prints this help message, then exits
          -c : prevents the generation of the CAN ID file
          -p : prevents the generation of the PIDs file
   		 -n : means no sorting and grouping by CAN ID or PID
   		 -m : means output in a format used by Mercedes
          <log file pathname>: provides a log file to be processed

Description:
This script will process the CAN messages in a format that is one generated by
one of the following lua scripts running on a RaceCapture device;
- CAN PID Prober.lua
- CAN Msg Logger.lua
- CAN Msg Logger HS.lua

The processing will do the following:
1)
- create a results file of the same name/extension with "-CANids" added to the
  name -- e.g., "capture.txt" will yield "capture-CANids.txt"
- ignore lines that are not CAN-message log entries
- add a field-heading text to the top of the results file
- optionally,  sort the CAN messages into groups where each group is the
  time-ordered collection of CAN messages from the same bus and having the same
  message ID
- compute the time duration between receipt of the CAN messages within the
  same group and add that field to the end of each message
- compute the time between the receipt of the first-logged CAN message and
  each subsequent CAN message and add that field to the end of each message
- separate the groups of CAN messages using a blank/empty line
- append some statistics to the end of the "-CANids" file
2)
- if any CAN messages exist that are responses to PID queries, then create a
  second results file of the same name/extension with "-PIDs" added to the
  name -- e.g., "capture.txt" will yield "capture-PIDs.txt"
- ignore lines that are not CAN-message log entries
- add a field-heading text to the top of the results file
- optionally, sort the CAN messages into groups where each group is the
  time-ordered collection of CAN messages from the same bus and having the same
  message PID
- compute the time duration between receipt of the CAN messages within the
  same group and add that field to the end of each message
- compute the time between the receipt of the first-logged CAN message and
  each subsequent CAN message and add that field to the end of each message
- separate the groups of CAN messages using a blank/empty line
- append some statistics to the end of the "-PIDs" file
'
		exit 1
	fi

	if test "$1" = '-n'
	then
		DO_SORTING='0'
		shift
		continue
	fi

	if test "$1" = '-c'
	then
		GENERATE_CAN_ID_FILE='0'
		shift
		continue
	fi

	if test "$1" = '-p'
	then
		GENERATE_PIDs_FILE='0'
		shift
		continue
	fi

	if test "$1" = '-m'
	then
		OUTPUT_MBZ_FORMAT='1'
		DO_SORTING='0'
		shift
		continue
	fi

	break
done
#echo "OUTPUT_MBZ_FORMAT = $OUTPUT_MBZ_FORMAT"

if test \( "$GENERATE_CAN_ID_FILE" = '0' \) -a \( "$GENERATE_PIDs_FILE" = '0' \)
then
	echo "\nBoth the CAN ID and the PIDs result files were suppressed ... quitting"
	exit 1
fi

while true
do
	if test -z "$1"
	then
		echo "\nNo more files to process ... quitting"
		break
	fi

	# get the file pathname, it's base filename & suffix and containing directory
	FILE_PATHNAME="$1"
	shift
	FILE_NAME=`/usr/bin/basename "$FILE_PATHNAME" | \
														/usr/bin/sed -e 's/^\(.*\)\..*$/\1/'`
	FILE_SUFFIX=`/usr/bin/basename "$FILE_PATHNAME" | /usr/bin/fgrep '.' | \
														/usr/bin/sed -e 's/^.*\(\..*\)$/\1/'`
	DIR=`/usr/bin/dirname "$FILE_PATHNAME"`
	#echo "SCRIPT_NAME = $SCRIPT_NAME"
	#echo "SCRIPT_SUFFIX = $SCRIPT_SUFFIX"

	# ensure the file exists
	if test ! -f "$FILE_PATHNAME"
	then
		echo 'The file:'
		echo "$FILE_PATHNAME"
		echo 'is not valid ... skipping this file ...'
		continue
	fi

	echo "\nProcessing '${FILE_NAME}$FILE_SUFFIX' ..."

	# determine the current CAN-message format:
	MSG_FORMAT=`
		/bin/cat "$FILE_PATHNAME" | /usr/bin/tr "\r" "\n" | \
		/usr/bin/sed -e '/^$/d' | \
		/usr/bin/egrep -e '^'"$RAW_HEX_LONG"'$' -e '^'"$RAW_HEX_SHORT"'$' \
							-e '^'"$RAW_DEC_LONG"'$' -e '^'"$RAW_DEC_SHORT"'$' | \
		/usr/bin/head -n 1 | \
		/usr/bin/awk '
		{
			# determine whether the CAN message is in long or short format
			if ((match($1, /^[0-9]{4}(-[0-9]{1,2}){2}$/) != 0) &&
				 (match($2, /^([0-9]{1,2}:){2}[0-9]{1,2}\.[0-9]{1,3}$/) != 0)) { # long
				fOffset = 0  # original code was for long-format CAN messages
				msgLenType = "LONG"
			}
			else {
				fOffset = -2  # field offset: 2 fewer fields in short-format msgs
				msgLenType = "SHORT"
			}

			# determine whether the CAN message is in hex or decimal format
			if (index($(fOffset + 6), "0x") == 1) { isHex = 1; msgNumType = "HEX" }
			else { isHex = 0; msgNumType = "DEC" }
            
			# the number of fields should be:
			# field offset + 7 + the number of message-data bytes
			if (isHex == 1) { numDataBytes = sprintf("%d", "0x"$(fOffset + 7)) }
			else { numDataBytes = $(fOffset + 7) }

			# ensure the number of fields is valid
			if (NF == (fOffset + 7 + numDataBytes)) {  # valid message format
				print "RAW-"msgNumType"-"msgLenType
			}
			else {  # invalid message format
				print "Invalid CAN-message format: "$0
			}
		}'`
		
	#echo "MSG_FORMAT = {$MSG_FORMAT}"

	# set the "valid message format" RE kind, the "is short format" and "is hex"
	# indicators and the "field offset" for the current CAN-message format
	case "$MSG_FORMAT" in
		'RAW-HEX-LONG')
			CURRENT_MSG_RE="$RAW_HEX_LONG"
			IS_SHORT_FORMAT='0'
			IS_HEX_FORMAT='1'
			FO=0
		;;
		'RAW-HEX-SHORT')
			CURRENT_MSG_RE="$RAW_HEX_SHORT"
			IS_SHORT_FORMAT='1'
			IS_HEX_FORMAT='1'
			FO=2
		;;
		'RAW-DEC-LONG')
			CURRENT_MSG_RE="$RAW_DEC_LONG"
			IS_SHORT_FORMAT='0'
			IS_HEX_FORMAT='0'
			FO=0
		;;
		'RAW-DEC-SHORT')
			CURRENT_MSG_RE="$RAW_DEC_SHORT"
			IS_SHORT_FORMAT='1'
			IS_HEX_FORMAT='0'
			FO=2
		;;
		'')
			echo "\nNo valid CAN messages found ... skipping this file\n"
			continue
		;;
		*)
			echo "\n$MSG_FORMAT"
			echo 'Run "checkCANmsgLogs.sh" to identify erroneous CAN messages.'
			echo "The first CAN message was not valid ... skipping this file\n"
			continue
		;;
	esac
	#echo "IS_HEX_FORMAT = $IS_HEX_FORMAT"
	#echo "IS_SHORT_FORMAT = $IS_SHORT_FORMAT"

	# ensure the CAN messages are in the "long format" (have date & time fields)
	if test "$IS_SHORT_FORMAT" = '1'
	then
		echo "\nThese CAN messages must be converted to long format."
		echo 'Run "applyTimeSyncToMsgs.sh" to convert the CAN messages.'
		echo "CAN-message format is not valid ... skipping this file\n"
		continue
	fi

	if test "$DO_SORTING" = '1'
	then
		# results file(s) are to be sorted and grouped
		if test IS_HEX_FORMAT = '1'
		then
			CAN_ID_SORT_CMD='/usr/bin/sort -g -k 4,4 -k 5,5 -k 3,3'
			PID_SORT_CMD='/usr/bin/sort -g -k 4,4 -k 7,7 -k 3,3'
		else
			CAN_ID_SORT_CMD='/usr/bin/sort -g -k 4,4 -k 6,6 -k 3,3'
			PID_SORT_CMD='/usr/bin/sort -g -k 4,4 -k 8,8 -k 3,3'
		fi

		OUTPUT_FORMAT='Sorted'
	else
		# "no sorting" means "sort by upTime"
		CAN_ID_SORT_CMD='/usr/bin/sort -g -k 3,3'
		PID_SORT_CMD='/usr/bin/sort -g -k 3,3'
		OUTPUT_FORMAT=''
	fi
	#echo "DO_SORTING = $DO_SORTING"

	if test "$OUTPUT_MBZ_FORMAT" = '1'
	then
		FILE_SUFFIX='.asc'
		OUTPUT_FORMAT='-MBZ'
	fi
	#echo "OUTPUT_FORMAT = $OUTPUT_FORMAT"

	# if required, create the CAN ID file, optionally sorted & grouped by CAN ID
	if test "$GENERATE_CAN_ID_FILE" = '1'
	then
		# determine the uptime of the first CAN-message record
		INITIAL_UPTIME=`
			/bin/cat "$FILE_PATHNAME" | /usr/bin/tr "\r" "\n" | \
			/usr/bin/sed -e '/^$/d' | \
			/usr/bin/egrep -e '^'"$CURRENT_MSG_RE"'$'  | \
			/usr/bin/head -n 1 |  /usr/bin/awk '{ print $(3 - '$FO') }'`
		#echo "INITIAL_UPTIME = $INITIAL_UPTIME"

		/bin/cat "$FILE_PATHNAME" | \
		# change to UNIX-type line endings and remove empty lines
		/usr/bin/tr "\r" "\n" | /usr/bin/sed -e '/^$/d' | \
		# only process valid records
		/usr/bin/egrep -e '^'"$CURRENT_MSG_RE"'$' | \
		# sort the CAN-message entries either via upTime or into CAN ID groups
		$CAN_ID_SORT_CMD | \
		# now have records of the form:
		# for hex captures:
		# YYYY-MM-DD HH:MM:SS.ms# <uptime ms> <bus num> <CAN ID> 0x<CAN ID> <# msg bytes> <msg byte> ...
		# for decimal captures:
		# YYYY-MM-DD HH:MM:SS.ms# <uptime ms> <bus num> 0x<CAN ID> <CAN ID> <# msg bytes> <msg byte> ...
		#
		# output the CAN IDs file
		/usr/bin/awk '
			BEGIN {
				isHex = '$IS_HEX_FORMAT'
				doSorting = '$DO_SORTING'
				doMBZformat = '$OUTPUT_MBZ_FORMAT'
				initialUpTime = "'"$INITIAL_UPTIME"'"
				finalUpTime = 0
				totalRecs = 0
				ms = 0

				if ((isHex == 1) && (doMBZformat == 0)) {
					print "         UTC              upTime  bus --- Message ----                          Message  Since First"
					print "   Date       Time         (ms)    #   ID    ID  bytes   Message Bytes (hex)    Interval    Message"
					print "---------- ------------  -------- --- ----  ----- ---  -----------------------  -------- -----------"
				}
				else if (doMBZformat == 1) { print "base hex  timestamps absolute" }
				else {
					print "         UTC              upTime  bus ---- Message ----                                  Message  Since First"
					print "   Date       Time         (ms)    #    ID    ID  bytes     Message Bytes (decimal)      Interval    Message"
					print "-----------------------  -------- --- -----  ----  ---  -------------------------------  -------- -----------"
				}
			}
			{
				# number of fields should be 7 + the number of message-data bytes
				if (isHex == 1) { numDataBytes = sprintf("%d", "0x"$7) }
				else { numDataBytes = $7 }

				# only process records that have the correct number of fields
				if (NF == (7 + numDataBytes)) {
					totalRecs++
					currUpTime = $3 + 0  # ensure it is a number
					if (currUpTime > finalUpTime) { finalUpTime = currUpTime }

					if (isHex == 1) { CANid = $5 }
					else { CANid = $6 }

					if ((NR == 1) && (doSorting == 0)) { prevUpTime = currUpTime }

					if (CANid != prevCANid) {
						if ((NR != 1) && (doSorting == 1) && (doMBZformat == 0)) {
							print ""
						}

						if (doSorting == 1) {
							prevUpTime = currUpTime
							prevCANid = CANid
						}
					}

					if (doMBZformat == 0) {
						print $0" "currUpTime-prevUpTime" ms  "currUpTime-initialUpTime" ms"
					}
					else {
						secs = \
							substr($3,1,(length($3)-3))"."substr($3,(length($3)-2))"0"

						if (isHex == 1) {
							printf("%s  %s  %03X    %s  %s  %X  %s %s %s %s %s %s %s %s\n",
									 secs, "1", CANid, "Rx", "d",
									 "0x"$7, $8, $9, $10, $11, $12, $13, $14, $15)
						}
						else {
							printf("%s  %s  %03X    %s  %s  %X  %02X %02X %02X %02X %02X %02X %02X %02X\n",
									 secs, "1", CANid, "Rx", "d",
									 $7, $8, $9, $10, $11, $12, $13, $14, $15)
						}
					}

					prevUpTime = currUpTime
					if (doSorting == 0) { prevCANid = CANid }
				}
				else {
					system("echo >&2")
					system("echo The following record does not have "(7 + numDataBytes)" fields: >&2")
					system("echo "$0" >&2")
					system("echo Record ignored ... >&2")
				}
			}
			END {
				if (totalRecs > 0) {
					secsDuration = ((finalUpTime - initialUpTime) / 1000)
					msgsPerSec = totalRecs / secsDuration
					printf("\n%d msgs in %d secs (average: %0.2f msgs/sec, 1 msg every %.2f ms)\n", \
							 totalRecs, secsDuration, msgsPerSec, ((1/msgsPerSec)*1000))
					printf("(Based upon first/last upTime values.)\n")
				}
			}' | \
		# remove a (likely non-ascii) EOL character sometimes added by CoolTerm
		/usr/bin/sed -e 's/ . \([0-9][0-9]* ms\)/  \1/' \
								> "$DIR/$FILE_NAME-CANids${OUTPUT_FORMAT}$FILE_SUFFIX"
		echo "\nGenerated '$FILE_NAME-CANids${OUTPUT_FORMAT}$FILE_SUFFIX'"
	fi

	# if required, create the PIDs file, optionally sorted and grouped by PID
	if test "$GENERATE_PIDs_FILE" = '1'
	then
		# determine the uptime of the first PID-response CAN-message record
		INITIAL_UPTIME=`
			/bin/cat "$FILE_PATHNAME" | /usr/bin/tr "\r" "\n" | \
			/usr/bin/sed -e '/^$/d' | \
			/usr/bin/grep -e '0x7E[8-F]' -e '0x18DAF1[12][0-8]' | \
			/usr/bin/head -n 1 |  /usr/bin/awk '{ print $(3 - '$FO') }'`
		#echo "INITIAL_UPTIME = $INITIAL_UPTIME"

		/bin/cat "$FILE_PATHNAME" | \
		# change to UNIX-type line endings and remove empty lines
		/usr/bin/tr "\r" "\n" | /usr/bin/sed -e '/^$/d' | \
		# only include lines that are PID-response messages
		/usr/bin/grep -e '0x7E[8-F]' -e '0x18DAF1[12][0-8]' | \
		# add the decimal and hex PID numbers to the beginning of each record
			/usr/bin/awk '
			{
				isHex = '$IS_HEX_FORMAT'

				if (doMBZformat == 0) {
					if (isHex == 1) {
						dPID = sprintf("%3d", "0x"$10)
						hPID = $10
						print dPID" "hPID" "$0
					}
					else {
						hPID = sprintf("%02X", $10)
						dPID = $10
						print hPID" "dPID" "$0
					}
				}
			}' | \
		# now have records of the form ...
		# for hex captures:
		# <decimal PID> <hex PID> YYYY-MM-DD HH:MM:SS.ms# <uptime ms> <bus num> <CAN ID> 0x<CAN ID> <# msg bytes> <msg byte> ...
		# for decimal captures:
		# <hex PID> <decimal PID> YYYY-MM-DD HH:MM:SS.ms# <uptime ms> <bus num> 0x<CAN ID> <CAN ID> <# msg bytes> <msg byte> ...
		#
		# re-order the placement of the added decimal and hex PID numbers
		/usr/bin/sed -E \
			-e 's/^([0-9 ]{2}[0-9]) ([0-9A-F]{2}) (.*[0-9]{4}  0x7E[8-F]  )(.*)$/\3\1  0x\2   \4/' \
			-e 's/^([0-9A-F]{2}) ([0-9]{3}) (.*0x7E[8-F]  [0-9]{4}  )(.*)$/\30x\1  \2   \4/' \
			-e 's/^([0-9A-F]{2}) ([0-9]{3}) (.*0x18DAF1[12][0-8]  [0-9]{4}  )(.*)$/\30x\1  \2   \4/' | \
		# now have records of the form:
		# for hex captures:
		# YYYY-MM-DD HH:MM:SS.ms# <uptime ms> <bus num> <CAN ID> 0x<CAN ID> <PID> 0x<PID> <# msg bytes> <msg byte> ...
		# for decimal captures:
		# YYYY-MM-DD HH:MM:SS.ms# <uptime ms> <bus num> 0x<CAN ID> <CAN ID> 0x<PID> <PID> <# msg bytes> <msg byte> ...
		#
		# sort the PID entries either via upTime or into PID-number groups
		$PID_SORT_CMD | \
		# output the PIDs file
		/usr/bin/awk '
			BEGIN {
				isHex = '$IS_HEX_FORMAT'
				doSorting = '$DO_SORTING'
				doMBZformat = '$OUTPUT_MBZ_FORMAT'
				initialUpTime = "'"$INITIAL_UPTIME"'"
				finalUpTime = 0
				totalRecs = 0
				currUpTime = 0

				if ((isHex == 1) && (doMBZformat == 0)) {
					print "         UTC              upTime  bus --------- Message ----------                          Message  Since First"
					print "   Date       Time         (ms)    #   ID    ID    PID  PID  bytes   Message Bytes (hex)    Interval    Message"
					print "---------- ------------  -------- --- ----  -----  ---  ----  ---  -----------------------  -------- -----------"
				}
				else if (doMBZformat == 1) { print "base hex  timestamps absolute" }
				else {
					print "         UTC              upTime  bus --------- Message -----------                                  Message  Since First"
					print "   Date       Time         (ms)    #    ID    ID    PID  PID  bytes     Message Bytes (decimal)      Interval    Message"
					print "-----------------------  -------- --- -----  ----  ----  ---   ---  -------------------------------  -------- -----------"
				}
			}
			{
				# number of fields should be 9 + the number of message-data bytes
				if (isHex == 1) { numDataBytes = sprintf("%d", "0x"$9) }
				else { numDataBytes = $9 }

				# only process records that have the correct number of fields
				if (NF == (9 + numDataBytes)) {
					totalRecs++
					currUpTime = $3  # ensure it is a number
					if (currUpTime > finalUpTime) { finalUpTime = currUpTime }

					if (isHex == 1) { CANid = $5 }
					else { CANid = $6 }

					if (isHex == 1) { PIDnum = $7 }
					else { PIDnum = $8 }

					if ((NR == 1) && (doSorting == 0)) { prevUpTime = currUpTime }

					if (PIDnum != prevPIDnum) {
						if ((NR != 1) && (doSorting == 1) && (doMBZformat == 0)) {
							print ""
						}

						if (doSorting == 1) {
							prevUpTime = currUpTime
							prevPIDnum = PIDnum
						}
					}

					if (doMBZformat == 0) {
						print $0" "currUpTime-prevUpTime" ms  "currUpTime-initialUpTime" ms"
					}
					else {
						secs = \
							substr($3,1,(length($3)-3))"."substr($3,(length($3)-2))"0"

						if (isHex == 1) {
							printf("%s  %s  %03X    %s  %s  %X  %s %s %s %s %s %s %s %s\n",
									 secs, "1", CANid, "Rx", "d",
									 "0x"$9, $10, $11, $12, $13, $14, $15, $16, $17)
						}
						else {
							printf("%s  %s  %03X    %s  %s  %X  %02X %02X %02X %02X %02X %02X %02X %02X\n",
									 secs, "1", CANid, "Rx", "d",
									 $9, $10, $11, $12, $13, $14, $15, $16, $17)
						}
					}

					prevUpTime = currUpTime
					if (doSorting == 0) { prevPIDnum = PIDnum }
				}
				else {
					system("echo >&2")
					system("echo The following record does not have "(9 + numDataBytes)" fields: >&2")
					system("echo "$0" >&2")
					system("echo Record ignored ... >&2")
				}
			}
			END {
				if (totalRecs > 0) {
					secsDuration = ((finalUpTime - initialUpTime) / 1000)
					msgsPerSec = totalRecs / secsDuration
					printf("\n%d msgs in %d secs (average: %0.2f msgs/sec, 1 msg every %.2f ms)\n", \
							 totalRecs, secsDuration, msgsPerSec, ((1/msgsPerSec)*1000))
					printf("(Based upon first/last upTime values.)\n")
				}
			}' | \
		# remove a (likely non-ascii) EOL character added by CoolTerm
		/usr/bin/sed -e 's/ . \([0-9][0-9]* ms\)/  \1/' \
									> "$DIR/$FILE_NAME-PIDs${OUTPUT_FORMAT}$FILE_SUFFIX"

		# announce file creation or perform clean-up of no-messages file
		if test -f "$DIR/$FILE_NAME-PIDs${OUTPUT_FORMAT}$FILE_SUFFIX"
		then
			if test `/usr/bin/head -n 4 \
								"$DIR/$FILE_NAME-PIDs${OUTPUT_FORMAT}$FILE_SUFFIX" | \
																			/usr/bin/wc -l` -gt 3
			then
				echo "\nGenerated '$FILE_NAME-PIDs${OUTPUT_FORMAT}$FILE_SUFFIX'"
			else
				# remove the empty PIDs file
				/bin/rm -f "$DIR/$FILE_NAME-PIDs${OUTPUT_FORMAT}$FILE_SUFFIX"
			fi
		fi
	fi

	echo
done
