#!/bin/sh
#set -x  ## Uncomment to get a trace
# (tabs are 3-spaces in width)

# 2020-Sep-12
# This material is free and withhout warranty.  Use it in any way you see fit.

# This script is designed to check the integrity of the CAN messages in one or
# more files that contain CAN messages logged by a lua/logger script runing on
# a RaceCapture device.  At least in my experience, it's normal for a small
# percentage of messages to get corrupted during the data-capture process.

# define the error-code help information
ERRS='
This script will report the following issues:
B#F : message byte # format error (leftmost byte is #1, next is #2, ...)
B#E : message byte # value error (leftmost byte is #1, next is #2, ...)
BNE : bus number error
CDE : decimal and hex CAN IDs differ error
DCF : decimal CAN ID format error
DTE : date value error
DTF : date format error
HCF : hex CAN ID format error
NBE : number of message bytes (<1 or >8) error
NBF : number of message bytes format error
NCF : non-conforming format
NFE : number of fields error
TME : time value error
TMF : time format error
UTE : non-increasing upTime or upTime <1 error
UTF : upTime format error
... mostly, look for added/missing spaces or bad characters'

# ------------------------------------------------------------------------------
# set regular expressions (REs) for valid CAN-message and time-sync line formats
# ------------------------------------------------------------------------------
DATE='[0-9]{4}(-[0-9]{1,2}){2}'
TIME='([0-9]{1,2}:){2}[0-9]{1,2}\.[0-9]{1,3}'
UP_TIME='[0-9]{1,9}'

RAW_HEX='[12] [0-9]{1,9} 0x[0-9A-Fa-f]{1,8} [0-9]{1,2}( 0x[0-9A-Fa-f]{1,2}){1,8}'
RAW_DEC='[12] [0-9]{1,9} 0x[0-9A-Fa-f]{1,8} [0-9]{1,2}( [0-9]{1,3}){1,8}'

# 
DATE_TIME=$DATE' '$TIME

# valid time-sync record with ONLY full date/time-stamp plus upTime
TIME_SYNC=$DATE_TIME' '$UP_TIME

# valid hexadecimal-format CAN message without date/time-stamp (short format)
RAW_HEX_SHORT=$UP_TIME' '$RAW_HEX

# valid hexadecimal-format CAN message with full date/time-stamp (long format)
RAW_HEX_LONG=$DATE_TIME' '$RAW_HEX_SHORT

# valid decimal-format CAN message without date/time-stamp (short format)
RAW_DEC_SHORT=$UPT_TIME' '$RAW_DEC

# valid decimal-format CAN message with full date/time-stamp (long format)
RAW_DEC_LONG=$DATE_TIME' '$RAW_DEC_SHORT
# ------------------------------------------------------------------------------

# quick 'n dirty options parsing
if test "$1" = '-h'
then
	echo '
Synopsis: checkCANmsgLogs.sh [-h] <log file pathname> ...
   where: -h : prints this help message, then exits
          <log file pathname>: provides a log file to be processed

Description:
This script will process the CAN messages in a format that is generated by one
of the following lua scripts running on a RaceCapture device;
- CAN PID Prober.lua
- CAN Msg Logger.lua
- CAN Msg Logger HS.lua

This script will create a file of the same name/extension with "-checked" added
to the name -- e.g., "trace.txt" will yield "trace-checked.txt"

In the "-checked" file, lines having identified issues will be prefixed with:
<3-character code><space><?><space>

By searching the "-checked" file for a question-mark [?], you can find and fix
or remove erroneous CAN-message records.
'"$ERRS"
	exit 1
fi

#echo "$ERRS"

while true
do
	if test -z "$1"
	then
		echo "\nNo more files to process ... quitting"
		break
	fi

	# get the file pathname, it's base filename & suffix and containing directory
	FILE_PATHNAME="$1"
	shift
	FILE_NAME=`/usr/bin/basename "$FILE_PATHNAME" | \
														/usr/bin/sed -e 's/^\(.*\)\..*$/\1/'`
	FILE_SUFFIX=`/usr/bin/basename "$FILE_PATHNAME" | /usr/bin/fgrep '.' | \
														/usr/bin/sed -e 's/^.*\(\..*\)$/\1/'`
	DIR=`/usr/bin/dirname "$FILE_PATHNAME"`
	#echo "SCRIPT_NAME = $SCRIPT_NAME"
	#echo "SCRIPT_SUFFIX = $SCRIPT_SUFFIX"

	# ensure the file exists
	if test ! -f "$FILE_PATHNAME"
	then
		echo 'The file:'
		echo "$FILE_PATHNAME"
		echo "is not valid ... skipping this file ...\n"
		continue
	fi

	echo "\nProcessing '${FILE_NAME}$FILE_SUFFIX' ..."

	# determine the current CAN-message format:
	MSG_FORMAT=`
		/bin/cat "$FILE_PATHNAME" | /usr/bin/tr "\r" "\n" | \
		/usr/bin/sed -e '/^$/d' | \
		/usr/bin/egrep -e '^'"$RAW_HEX_LONG"'$' -e '^'"$RAW_HEX_SHORT"'$' \
							-e '^'"$RAW_DEC_LONG"'$' -e '^'"$RAW_DEC_SHORT"'$' | \
		/usr/bin/head -n 1 | \
		/usr/bin/awk '
		{
			# determine whether the CAN message is in long or short format
			if ((match($1, /^[0-9]{4}(-[0-9]{1,2}){2}$/) != 0) &&
				 (match($2, /^([0-9]{1,2}:){2}[0-9]{1,2}\.[0-9]{1,3}$/) != 0)) { # long
				fOffset = 0  # original code was for long-format CAN messages
				msgLenType = "LONG"
			}
			else {
				fOffset = -2  # field offset: 2 fewer fields in short-format msgs
				msgLenType = "SHORT"
			}
            
			# determine whether the CAN message is in hex or decimal format
			if (index($(fOffset + 6), "0x") == 1) { isHex = 1; msgNumType = "HEX" }
			else { isHex = 0; msgNumType = "DEC" }

			# the number of fields should be:
			# field offset + 7 + the number of message-data bytes
			if (isHex == 1) { numDataBytes = sprintf("%d", "0x"$(fOffset + 7)) }
			else { numDataBytes = $(fOffset + 7) }

			# ensure the number of fields is valid
			if (NF == (fOffset + 7 + numDataBytes)) {  # valid message format
				print "RAW-"msgNumType"-"msgLenType
			}
			else {  # invalid message format
				print "Invalid CAN-message format: "$0
			}
		}'`
		
	#echo "MSG_FORMAT = {$MSG_FORMAT}"

	# set the "valid message format" RE kind, the "is short format" and "is hex"
	# indicators and the "field offset" for the current CAN-message format
	case "$MSG_FORMAT" in
		'RAW-HEX-LONG')
			CURRENT_MSG_RE="$RAW_HEX_LONG"
			IS_SHORT_FORMAT='0'
			IS_HEX_FORMAT='1'
			#FO=0
		;;
		'RAW-HEX-SHORT')
			CURRENT_MSG_RE="$RAW_HEX_SHORT"
			IS_SHORT_FORMAT='1'
			IS_HEX_FORMAT='1'
			#FO=2
		;;
		'RAW-DEC-LONG')
			CURRENT_MSG_RE="$RAW_DEC_LONG"
			IS_SHORT_FORMAT='0'
			IS_HEX_FORMAT='0'
			#FO=0
		;;
		'RAW-DEC-SHORT')
			CURRENT_MSG_RE="$RAW_DEC_SHORT"
			IS_SHORT_FORMAT='1'
			IS_HEX_FORMAT='0'
			#FO=2
		;;
		'')
			echo "\nNo valid CAN messages were found ... skipping this file\n"
			continue
		;;
		*)
			echo "\n$MSG_FORMAT"
			echo 'Run "checkCANmsgLogs.sh" to identify erroneous CAN messages.'
			echo "The first CAN message was not valid ... skipping this file\n"
			continue
		;;
	esac
	#echo "IS_HEX_FORMAT = $IS_HEX_FORMAT"
	#echo "IS_SHORT_FORMAT = $IS_SHORT_FORMAT"

	/bin/cat "$FILE_PATHNAME" | \
	# change to UNIX-type line endings and remove empty lines
	/usr/bin/tr "\r" "\n" | /usr/bin/sed -e '/^$/d' | \
	# prefix lines that are not a valid CAN-message format with '? '
	/usr/bin/sed -E -e '/^'"$CURRENT_MSG_RE"'$/ ! s/^(.*)$/\? \1/' | \
	# unmark lines that are time-sync entries
	/usr/bin/sed -E -e 's/\? ('"$TIME_SYNC"')$/\1/' | \
	# output the CAN IDs file
	/usr/bin/awk '
		BEGIN {
			isShort = '$IS_SHORT_FORMAT'
			isHex = '$IS_HEX_FORMAT'
			currYear = 0
			currUpTime = 0
			prevUpTime = 0
		}
		{
			while (1 == 1) {
				# field offset: number to add to field number to get correct field
				fo = 0

				# offset the field numbers by -2 if the CAN-message format is short
				if (isShort == 1) { fo = -2 }

				# offset the field numbers by +1 if the record is marked
				if (($1 == "?") && (length($1) == 3)) { fo++ }

				# the number of fields should be:
				# field offset + 7 + the number of message-data bytes
				if (isHex == 1) { numDataBytes = sprintf("%d", "0x"$(fo + 7)) }
				else { numDataBytes = $(fo + 7) }

				# check records that have the correct number of fields
				if ((NF == (fo + 7 + numDataBytes)) ||  # a message record
					 (NF == 3)) {  # a time-sync record

					# if this is a time-sync, the isShort offset does not apply
					if ((NF == 3) && (isShort == 1)) { fo = fo + 2 }

					# the date and time fields are only on long-format messages and
					# time-sync records
					if ((isShort == 0) || (NF == 3)) {
						# check date field
						date = $(fo + 1)
						format = match(date, /^[0-9]{4}(-[0-9]{1,2}){2}$/)

						if (format == 0) {
							if ($1 == "?") { print "DTF "$0 } else { print "DTF ? "$0 }
							break
						}

						# ensure the year, month and day values are within range
						year = substr(date, 1, 4) + 0
						month = substr(date, 6, 2) + 0
						day = substr(date, 9, 2) + 0

						# if date is 1970 "fill-in" date, ensure MM-DD is 01-01
						if ((year == 1970) && ((month != 1) || (day != 1))) {
							if ($1 == "?") { print "DTE "$0 } else { print "DTE ? "$0 }
							break
						}

						if (currYear == 0) {  # have not yet had a time-sync date
							if ((year != 1970) && (year < 2020)) {
								if ($1 == "?") { print "DTE "$0 }
								else { print "DTE ? "$0 }

								break
							}
						}
						else {  # have had a time-sync, allow end-of-year crossing
							if ((year != 1970) &&
								 (year != currYear) &&
								 (year != (currYear + 1))) {
								if ($1 == "?") { print "DTE "$0 }
								else { print "DTE ? "$0 }

								break
							}
						}

						if ((month < 1) || (month > 12) || (day < 1) || (day > 31)) {
							if ($1 == "?") { print "DTE "$0 } else { print "DTE ? "$0 }
							break
						}

						# check time field
						time = $(fo + 2)
						format = match(time, /^([0-9]{1,2}:){2}[0-9]{1,2}\.[0-9]{1,3}$/)

						if (format == 0) {
							if ($1 == "?") { print "TMF "$0 } else { print "TMF ? "$0 }
							break
						}

						# if date is 1970 "fill-in" date, ensure time is 00:00:00
						if ((date == "1970-01-01") && (time != "00:00:00.000")) {
							if ($1 == "?") { print "TME "$0 } else { print "TME ? "$0 }
							break
						}

						# ensure the hour, minute and second values are within range
						hour = substr(time, 1, 2) + 0
						minute = substr(time, 4, 2) + 0
						second = substr(time, 7, 2) + 0

						if ((hour < 0) || (hour > 24) ||
							 (minute < 0) || (minute > 59) ||
							 (second < 0) || (second > 59)) {
							if ($1 == "?") { print "TME "$0 } else { print "TME ? "$0 }
							break
						}
					}
					else {
						year = 0
						month = 0
						day = 0
						hour = 0
						minute = 0
						second = 0
					}

					# check upTime field
					currUpTime = $(fo + 3)
					format = match(currUpTime, /^[0-9]{1,8}$/)

					if (format == 0) {
						if ($1 == "?") { print "UTF "$0 } else { print "UTF ? "$0 }
						break
					}

					# ensure the upTime count is always increasing
					currUpTime = currUpTime + 0  # ensure it is a number

					if ((currUpTime < prevUpTime) || (currUpTime <= 0)) {
						if ($1 == "?") { print "UTE "$0 } else { print "UTE ? "$0 }
						break
					}

					prevUpTime = currUpTime

					# if this is a time-sync record, capture the current year then
					# proceed to the next record
					if (NF == 3) {
						currYear = year
						break
					}

					# if this is not a 1970 "fill-in" date, set the current year
					if (year != 1970) {
						currYear = year
					}

					# check the bus number
					busNum = $(fo + 4) + 0  # ensure it is a number

					if ((busNum != 1) && (busNum != 2)) {
						if ($1 == "?") { print "BNE "$0 } else { print "BNE ? "$0 }
						break
					}

					# check the decimal CAN ID
					if (isHex == 1) { DcanID = $(fo + 5) }
					else { DcanID = $(fo + 6) }

					format = match(DcanID, /^[0-9]{1,10}$/)

					if (format == 0) {
						if ($1 == "?") { print "DCF "$0 } else { print "DCF ? "$0 }
						break
					}

					# check the hex CAN ID
					if (isHex == 1) { HcanID = $(fo + 6) }
					else { HcanID = $(fo + 5) }

					format = match(HcanID, /^0x[0-9A-F]{1,8}$/)

					if (format == 0) {
						if ($1 == "?") { print "HCF "$0 } else { print "HCF ? "$0 }
						break
					}

					# ensure the decimal and hex CAN IDs match
					if ((DcanID + 0) != (sprintf("%d", HcanID) + 0)) {
						if ($1 == "?") { print "CDE "$0 } else { print "CDE ? "$0 }
						break
					}

					# check the number of message bytes count
					numBytes = $(fo + 7)

					if (isHex == 1) { format = match(numBytes, /^[0-9A-F]{1,2}$/) }
					else { format = match(numBytes, /^[0-9]{1,3}$/) }

					if (format == 0) {
						if ($1 == "?") { print "NBF "$0 } else { print "NBF ? "$0 }
						break
					}

					# ensure the number of message bytes is within range
					if (isHex) { nBytes = (sprintf("%d", "0x"numBytes) + 0) }
					else { nBytes = (sprintf("%d", numBytes) + 0) }

					if ((nBytes < 1) || (nBytes > 8)) {
						if ($1 == "?") { print "NBE "$0 } else { print "NBE ? "$0 }
						break
					}

					# check the message bytes
					for (i = (fo + 8); i <= NF; i++) {
						byteNum = i - (fo + 7)
						byte = $i

						if (isHex == 1) { format = match(byte, /^[0-9A-F]{1,2}$/) }
						else { format = match(byte, /^[0-9]{1,3}$/) }

						if (format == 0) {
							if ($1 == "?") { print "B"byteNum"F "$0 }
							else { print "B"byteNum"F ? "$0 }

							break
						}

						# ensure the value of message byte is within range
						if (isHex) { byteVal = sprintf("%d", "0x"byte) }
						else { byteVal = sprintf("%d", byte)}

						# force byteVal to be a number
						byteVal = byteVal + 0

						if ((byteVal < 0) || (byteVal > 255)) {
							if ($1 == "?") { print "B"byteNum"E "$0 }
							else { print "B"byteNum"E ? "$0 }

							break
						}
					}

					# add the 3-character code to non-conforming format lines
					if ($1 == "?") { print "NCF "$0; break }

					# no issues identified with this record, print it
					print $0
					break
				}
				else {  # add code to records having an incorrect number of fields
					if ($1 == "?") { print "NFE "$0 } else { print "NFE ? "$0 }
					break
				}
			}
		}' > "$DIR/$FILE_NAME-checked$FILE_SUFFIX"

	echo "\nGenerated '$FILE_NAME-checked$FILE_SUFFIX'\n"
done
